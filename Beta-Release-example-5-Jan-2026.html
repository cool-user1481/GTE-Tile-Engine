<!--

DISCLAIMER: This is a super early demo, it's really bad. Just post issues here of things I need to fix.
I kinda forgot to check canvas resize and also forgot about a few construsctor params. I hope there are no bugs there.

-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTE (GTE Tile Engine)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
            font-family: 'LanaPixel', monospace;
            color: white;
            user-select: none;
        }

        #canvas {
            display: absolute;
            z-index: 101;
        }

        #range {
            z-index: 100;
            display: absolute;
        }
    </style>
</head>

<body>
    <div id="fpsMeter">FPS: --</div>
    <label for="range">error</label>
    <canvas id="canvas"></canvas>
    <script>
        let questionableFpsImproverEnabled = false; // Yeahhh, this doesn't really work, but it doesn't need it
        if (questionableFpsImproverEnabled) {
            window.requestAnimationFrame = function(callback) {
                return setTimeout(function() {
                    callback(performance.now());
                }, 0);
            };
        }


        class GameEngine {
            constructor(canvas, bgImg, tilesConfig = {}, bounds = {
                xmax: 16,
                ymax: 16,
                xmin: -16,
                ymin: -16,
                zoomMax: 1.5,
                zoomMin: 0.125,
            }, tiles = [], tileSize = 128) {
                this.keys = {};
                this.bounds = bounds;
                this.tilesConfig = tilesConfig;
                this.tiles = [{
                        name: "inferno_block",
                        x: 0,
                        y: 0,
                    },
                    {
                        x: 1,
                        y: 1,
                        name: "wood_chest"
                    }
                ];
                this.tileSize = tileSize;
                this.canvas = canvas;
                this.ctx = this.canvas.getContext('2d');
                this.bgImg = bgImg;
                this.OSC = document.createElement('canvas');
                this.Octx = this.OSC.getContext('2d');
                this.OSC.width = this.bgImg.naturalWidth;
                this.OSC.height = this.bgImg.height;
                this.OSC.height = this.bgImg.naturalHeight;
                this.Octx.drawImage(this.bgImg, 0, 0);
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 1,
                };
                this.mouse = {
                    x: 0,
                    y: 0,
                    worldX: 0,
                    worldY: 0,
                }
                this.xv = 0;
                this.yv = 0;
                this.zv = 0;
                this.resize();
                this.initEvents();
                this.loop();
                this.tiles.push({
                    x: this.bounds.xmax - 1,
                    y: this.bounds.ymax - 1,
                    name: "water"
                })
                this.tiles.push({
                    x: this.bounds.xmin,
                    y: this.bounds.ymin,
                    name: "inferno_block"
                })

            }


            initEvents() {
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), {
                    passive: false
                });
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            loop() {
                this.keyFunction();
                this.render();
                document.querySelector('label[for="range"]').innerHTML = "zoom: " + this.camera.zoom;

                requestAnimationFrame(this.loop.bind(this));
            }


            render() {
                let ctx = this.ctx;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const pat = ctx.createPattern(this.OSC, "repeat");
                const matrix = new DOMMatrix();
                matrix.translateSelf(this.camera.x * 1, this.camera.y * 1); // X offset, Y offset
                pat.setTransform(matrix);
                ctx.save();
                const scaleFactor = this.camera.zoom;
                ctx.scale(scaleFactor, scaleFactor);

                ctx.fillStyle = pat;
                ctx.fillRect(0, 0, canvas.width / scaleFactor, canvas.height / scaleFactor);

                ctx.restore();

                ctx.rect(0, 0, 10, 10);
                ctx.fillStyle = pat;
                ctx.fill();
                // Holy, after 5+ hours of work, the bg section is done and good enough.
                this.tiles.forEach((element, index) => {
                    const config = this.tilesConfig;
                    this.ctx.imageSmoothingEnabled = config.smoothing;
                    let screenX = this.worldToCanvasCordsX(element.x);
                    let screenY = this.worldToCanvasCordsY(element.y);
                    let scaledTileSize = this.tileSize * this.camera.zoom;
                    if (!config.items[element.name]) {
                        alert(`error: the block requested, ${element.name}, does not have a match in the config.`)
                    }
                    ctx.drawImage(
                        atlas,
                        config.items[element.name].x * config.w, config.items[element.name].y * config.h, config.w, config.h,
                        screenX, screenY, scaledTileSize, scaledTileSize
                    );
                })

            }
            handleMouseDown(e) {
                if (e.button === 0) { // Left click
                    console.log("click")
                    this.tiles.push({
                        x: this.canvasToWorldCordsX(this.mouse.x),
                        y: this.canvasToWorldCordsY(this.mouse.y),
                        name: "lava"
                    })
                }
                if (e.button === 1) { // Middle click
                    console.log("click1")
                    e.preventDefault();
                }
                if (e.button === 2) { // Right click
                    console.log("click2")
                }
            }

            canvasToWorldCordsX(input) {
                return Math.floor((input - this.camera.x * this.camera.zoom) / (this.tileSize * this.camera.zoom));
            }

            canvasToWorldCordsY(input) {
                return Math.floor((input - this.camera.y * this.camera.zoom) / (this.tileSize * this.camera.zoom));
            }

            worldToCanvasCordsX(input) {
                return (input * this.tileSize + this.camera.x) * this.camera.zoom;
            }

            worldToCanvasCordsY(input) {
                return (input * this.tileSize + this.camera.y) * this.camera.zoom;
            }

            worldToCameraCordsX(input) {
                return input * this.tileSize - this.camera.x / this.camera.zoom - 2 * this.canvas.getBoundingClientRect().left;
            }

            worldToCameraCordsY(input) {
                return input * this.tileSize - this.camera.y / this.camera.zoom - 2 * this.canvas.getBoundingClientRect().top;
            }

            keyFunction() {
                this.camera.zoom = Math.min(Math.max(this.bounds.zoomMin, this.camera.zoom), this.bounds.zoomMax);
                let moveSpeed = 15 / this.camera.zoom;
                let zoomSpeed = this.camera.zoom ** 0.5 / 50;
                /*if(this.camera.x - this.canvas.width*2 < this.worldToCameraCordsX(this.bounds.xmin * 2)){
                    this.camera.x += -0.1 * (this.camera.x - this.worldToCameraCordsX(this.bounds.xmin * 2) - this.canvas.width*2);
                }
                if(this.camera.x > this.worldToCameraCordsX(this.bounds.xmax * 2)){
                    this.camera.x -= 0.1 * (this.camera.x - this.worldToCameraCordsX(this.bounds.xmax * 2))
                }
                if(this.camera.y - this.canvas.height*2 < this.worldToCameraCordsY(this.bounds.ymin * 2)){
                    this.camera.y += -0.1 * (this.camera.y - this.worldToCameraCordsY(this.bounds.ymin * 2) - this.canvas.height*2);
                }
                if(this.camera.y > this.worldToCameraCordsY(this.bounds.ymax * 2)){
                    this.camera.y -= 0.1 * (this.camera.y - this.worldToCameraCordsY(this.bounds.ymax * 2))
                }*/
                // All bounds stuff is a WIP for now

                this.xv /= 1.45 / (((this.camera.zoom - 1) / 4) + 1);
                this.yv /= 1.45 / (((this.camera.zoom - 1) / 4) + 1);
                this.zv /= 1.25;
                this.camera.x += this.xv;
                this.camera.y += this.yv;
                this.camera.zoom *= this.zv + 1;

                if (this.keys.ArrowLeft || this.keys.a) {
                    this.xv += moveSpeed;
                }
                if (this.keys.ArrowRight || this.keys.d) {
                    this.xv -= moveSpeed;
                }
                if (this.keys.ArrowUp || this.keys.w) {
                    this.yv += moveSpeed;
                }
                if (this.keys.ArrowDown || this.keys.s) {
                    this.yv -= moveSpeed;
                }
                if (this.keys.PageUp) {
                    this.zv += zoomSpeed;
                }
                if (this.keys.PageDown) {
                    this.zv -= zoomSpeed;
                }
            }

            handleMouseMove(e) {
                this.mouse.x = e.clientX - this.canvas.getBoundingClientRect().left;
                this.mouse.y = e.clientY - this.canvas.getBoundingClientRect().top;
                this.mouse.worldX = this.canvasToWorldCordsX(this.mouse.x)
                this.mouse.worldY = this.canvasToWorldCordsY(this.mouse.y)
            }

            handleMouseUp() {

            }

            handleWheel(e) {
                e.preventDefault();
                this.zv += e.deltaY * this.camera.zoom ** 0.001 / -2000;
            }

            handleKeyDown(e) {
                this.keys[e.key] = true;
                if (e.key.startsWith("Arrow") || e.key.startsWith("Page")) {
                    e.preventDefault()
                }
            }

            handleKeyUp(e) {
                this.keys[e.key] = false;
            }

            createTile(x, y, color = '#00ff00') {

            }

            getMouseWorldCoords() {
                return {
                    x: this.canvasToWorldCordsX(this.mouse.x),
                    y: this.canvasToWorldCordsY(this.mouse.y),
                }
            }
        }

        let atlas = new Image();
        atlas.src = 'https://static.wikitide.net/cuberealmwiki/9/9a/Cuberealm_block_spritesheet.png';
        let game;
        let bgImg = new Image();
        bgImg.src = "https://img.freepik.com/premium-vector/ground-seamless-pattern_172107-1588.jpg?w=2000";
        const tileConfig = {
            smoothing: false,
            atlas: atlas,
            w: 16,
            h: 16,
            items: {
                wood_chest: {
                    x: 1,
                    y: 11
                },
                inferno_block: {
                    x: 14,
                    y: 3
                },
                water: {
                    x: 0,
                    y: 0
                },
                lava: {
                    x: 0,
                    y: 1
                },
            },
        }

        atlas.decode()
            .then(() => {
                bgImg.decode()
                    .then(() => {
                        game = new GameEngine(document.getElementById('canvas'), bgImg, tileConfig);
                    });
            });

    </script>

    <script>
// Fps meter to show how performance it is!
        (function() {
            const fpsDisplay = document.getElementById('fpsMeter');
            let lastFrameTime = performance.now();
            let frameCount = 0;
            let fps = 0;
            let lastFpsUpdate = performance.now();

            function updateFPS() {
                const now = performance.now();
                frameCount++;

                if (now - lastFpsUpdate >= 500) {
                    fps = (frameCount * 1000) / (now - lastFpsUpdate);
                    fpsDisplay.textContent = `FPS: ${fps.toFixed(1)}`;
                    lastFpsUpdate = now;
                    frameCount = 0;
                }

                lastFrameTime = now;
                requestAnimationFrame(updateFPS);
            }

            requestAnimationFrame(updateFPS);
        })();
    </script>
</body>

</html>
